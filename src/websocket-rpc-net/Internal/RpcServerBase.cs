using Nickogl.WebSockets.Rpc.Serialization;
using System.Buffers;

namespace Nickogl.WebSockets.Rpc.Internal;

/// <summary>
/// Base class for every generated RPC server.
/// </summary>
public abstract partial class RpcServerBase<TClient> where TClient : RpcClientBase
{
	/// <summary>Time after which clients are disconnected if they fail to send ping frames.</summary>
	/// <remarks>By default, this is null, which disables quick detection of disconnects.</remarks>
	protected virtual TimeSpan? ClientTimeout => null;

	/// <summary>Time provider to use for enforcing the <see cref="ClientTimeout"/>.</summary>
	/// <remarks>This allows you to control the flow of time in tests.</remarks>
	protected virtual TimeProvider? TimeProvider => null;

	/// <summary>
	/// Called when the client is about to enter the message processing loop.
	/// </summary>
	/// <param name="client">Client who has connected.</param>
	protected virtual ValueTask OnConnectedAsync(TClient client)
	{
		return ValueTask.CompletedTask;
	}

	/// <summary>
	/// Called when the client has disconnected from the server. Its websocket is unusable at this point.
	/// </summary>
	/// <param name="client">Client who is about to disconnect.</param>
	protected virtual ValueTask OnDisconnectedAsync(TClient client)
	{
		return ValueTask.CompletedTask;
	}

	/// <summary>
	/// Get an RPC message reader for reading a single message.
	/// </summary>
	/// <remarks>
	/// <para>
	/// By default, the reader's underlying buffer uses the shared array pool,
	/// allocates a minimum of 1 KiB and grows exponentially until 16 KiB, after
	/// which it closes the client. If you need to tweak these options, override
	/// this method.
	/// </para>
	/// <para>
	/// By default, this allocates a new instance of <see cref="RpcMessageReader"/>
	/// every time a message is received from the client. Depending on your load
	/// profile, you may want to re-use or pool these instances, but always make
	/// sure to benchmark your RPC server to see if this has any benefits.
	/// </para>
	/// </remarks>
	protected virtual IRpcMessageReader GetMessageReader()
	{
		return new RpcMessageReader(new()
		{
			Pool = ArrayPool<byte>.Shared,
			MinimumSize = 1024,
			MaximumSize = 1024 * 16,
		});
	}

	/// <summary>
	/// Return the RPC message reader acquired by <see cref="GetMessageReader"/>.
	/// </summary>
	/// <param name="messageReader">RPC message reader to return.</param>
	protected virtual void ReturnMessageReader(IRpcMessageReader messageReader)
	{
		messageReader.Dispose();
	}

	/// <summary>
	/// Dispatch a remote procedure call from the client.
	/// </summary>
	/// <remarks>This method's implementation is generated by the source generator.</remarks>
	/// <param name="client">Client who sent the RPC message.</param>
	/// <param name="methodKey">Key of the method called by the client.</param>
	/// <param name="messageReader">Reader to read the parameters of the method.</param>
	protected abstract ValueTask DispatchAsync(TClient client, int methodKey, IRpcMessageReader messageReader);
}
